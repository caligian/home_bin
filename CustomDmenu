#!/usr/bin/perl

use autodie; 
use URI::Encode 'uri_encode'; 
use Clone 'clone'; 
use Getopt::Long;
use YAML::XS qw(Dump LoadFile);
use strict;
use warnings;
use Scalar::Util qw(reftype);
use Data::Dumper; 

my $mainconfig = {};
my $command = {};
my $config = {};
my $settings = "$ENV{HOME}/.config/CustomDmenu/config1.yaml";
my $home = "$ENV{HOME}";
my $recentf = "$home/.config/CustomDmenu/recentf.yaml";

my $help = "
$0: Make a custom interactive menu using rofi/dmenu 

--category   [STR]  
Show the menu for this category. 

--command    [STR]
When defined with --category, add this command to that category. 

Syntax:
cat::command,[cat::command,[cat::command,[cat::command[...]]]]

--i3-themes  [FLAG]
Display a menu which contains all the user defined i3-themes defined by i3-colors

--pkill	     [FLAG]
Display a menu containing all the running processes defined by ps -e. Use this menu to pkill those processes 

--cache	     [FLAG]
Build the cache. Run this after updating the config. 

--fm	     [FLAG]
Start file manager.

--all	     [FLAG]
Display all the categories 

--normal     [FLAG]
Display the usual dmenu/rofi menu 

--rofi	     [FLAG]
Use rofi instead of dmenu 

    ";

my (
    $fm,
    $showHelp,
    $appendCommand,
    $category,
    $themes,
    $pkill,
    $all,
    $normal,
    $rofi,
    ) = (0, 0, "", "", 0, 0, 0, 0, 0);

GetOptions(
    "fm", \$fm,
    "command=s",   \$appendCommand,
    "category=s",  \$category,
    "help",	   \$showHelp,
    "i3-themes",   \$themes,
    "pkill",	   \$pkill,
    "normal",	   \$normal,
    "rofi",	   \$rofi,
    "all",	   \$all,
    );  


die "$help\n" if $showHelp; 

$mainconfig = LoadConfig();
$command = $mainconfig->{categories};

my @t = keys %{$command->{apps}{Websites}->{apps}}; 
$command->{apps}->{Websites} = AddBrowserToWebsiteLinks($command->{apps}->{Websites});
$config = $mainconfig->{config};

my $dmenuParams = GetDmenuParameters();
@t = keys %{$command->{apps}};
map {
    my $this = $command->{apps}->{$_}; 
    my @tk = keys %{$this->{apps}}; 
    $this = BuildCache($this, \@tk, $dmenuParams);
    
} @t; 

if ($category and $appendCommand) {
    AppendCommand($category, $appendCommand);
} elsif ($category) {
    my $isWeb = $category eq "Websites" ? 1 : 0;
    Executor($command->{apps}{$category}, $dmenuParams, $isWeb); 

} elsif ($themes) {
    Handlei3Colors();
    my $reloadConfigPath = $config->{reloadConfig};
    $reloadConfigPath = '/usr/bin/reloadConfig' unless $reloadConfigPath; 
    qx/$reloadConfigPath/; 
} elsif ($pkill) {
    HandlePkill(); 
} elsif ($all) {
    ShowDrawers(); 
} else {
    my $dmenuParams = GetDmenuParameters(); 
    my $cmd = sprintf "dmenu_run %s", $dmenuParams; 
    qx/$cmd/;
}  	

###############################################################

sub AddBrowserToWebsiteLinks {
    my $hashref  = $_[0];
    my $default = $hashref->{default} ? $hashref->{default} : '$[browserNewTab]';
    my $apps = $hashref->{apps};
    my @keys = keys %$apps;

    foreach my $k (@keys) {
	my $a = $apps->{$k}; 
	unless (reftype $apps->{$k}) {
	    $hashref->{apps}->{$k} = "$default $a";
            
	} else {
	    $hashref->{apps}->{$k}= AddBrowserToWebsiteLinks($a) if defined $a->{apps}; 
	}
    }

    return $hashref; 
}

sub LoadConfig {
    $config = LoadFile($settings);
    my $cache = "$ENV{HOME}/.config/CustomDmenu/config.cache"; 
    # if (-f $cache and $buildCache) {
	
    # }
    
    return $config; 
}

sub WriteConfig {
    open my $FH, ">", $settings;
    my $yaml = Dump($mainconfig);
    print $FH $yaml; 
}

sub GetDmenuParameters {
    return $mainconfig->{config}->{dmenuParams} if $mainconfig->{config}->{dmenuParams} ne ""; 
    my $loc = $mainconfig->{config}->{i3config};
    open my $fh, "<", $loc;
    my @lines = <$fh>;
    close $fh;
    my $found = 0;
    my $dmenuParams = "";
    my $idx = 0;
    foreach my $line (@lines) {
	if ($line =~ /dmenu_run\s*(-.+)/) {
	    $dmenuParams = $1; 
	    $found = 1;
	    last;
	}
	++$idx;
    }
    die "Dmenu is not being used. Exiting.\n" if not $found;
    return $dmenuParams; 
}

sub SortNaturally {
    my ($m, $n) = ($a, $b); 
    my $limit = length $a > length $b ? length $a : length $b;
    
    for (my $i=0; $i<$limit; $i++) {
	my $m = substr $m, $i, 1;
	my $n = substr $n, $i, 1;
	my $comp  = $m cmp $n;
	if ($comp == 0) {
	    next; 
	} elsif ($comp == -1) {
	    return -1; 
	} else {
	    return 1; 
	}
    }
    return 0; 
}

sub FindCategoryIndex  { 
    my @arr = @{$_[0]};
    my $search = $_[2];

    my $index = $_[3] ? $_[3] : 0;
    
    
    return -1 if scalar @arr == 1;
    my @nextarr = $arr[1..scalar @arr-1]; 
    return $arr[0] eq $search ? $index : FindCategoryIndex(\@nextarr,$search, $index+1); 
    
}

sub FindCategory { 
    my $arr = $_[0];
    my $search = $_[1]; 
    return $arr->[FindCategoryIndex($arr, $search)]; 
}

sub FindCommandByCategory { 
    my ($hashref, $arr, $search) = @_;
    return $hashref->{FindCategory($arr, $search)};
} 

sub WriteCommandString { 
    my @cats = @{$_[0]};
    my $tempfile = qx(mktemp);
    chomp $tempfile; 
    open my $fh, ">>", $tempfile;
    map { print $fh $_ . "\n" } @cats;
    close $fh;
    return $tempfile; 
}

sub ShowCategories { 
    my @cats = @{$_[0]};
    my $dmenuParams = $_[1]; 
    my $tempfilepath = WriteCommandString(\@cats);
    my $prog = ""; 
    if ($rofi) {
	$prog = qx(cat $tempfilepath | rofi -i -dmenu  || rm $tempfilepath) ;
    } else {
	$prog = qx(cat $tempfilepath | dmenu -i $dmenuParams || rm $tempfilepath) ;
    }
    
    chomp $prog; 
    return Trim($prog);
} 

sub SortCategories { 
    my @cats = @{$_[0]};
    return sort { SortNaturally() } @cats; 
}

sub ReplaceAlias { 
    my $str = $_[0];
    my $alias = $_[1];
    my $aliascleaned = GetAliasName($alias);

    return $str if $aliascleaned eq "args"; 
    my $repl = $config->{aliases}->{$aliascleaned} or die "Alias[$aliascleaned] not found.\n";

    $str =~ s/\$\[\s*$aliascleaned\s*\]/$repl/;
    return $str; 
} 

sub Trim {
    return $_[0] =~ s/^\s*//r =~ s/^\s*$//rg; 
} 

sub GetAliasName {
    my $alias = $_[0] =~  s/\$ \[ ([^\]]+) \] /$1/rx;
    return Trim($alias); 
} 

sub ReplaceAllAliases { 
    my $str = $_[0];
    
    while ($str=~ /(\$\[ [^\]]+ \])/xg) {
	next if $1 =~ /args/;
	$str = ReplaceAlias($str, $1);
    }
    
    return $str; 
}

sub ReplaceAliasWith { 
    my ($str, $a, $b, $noSub) = @_;
    $a = GetAliasName($a);
    $str =~ s/\$\[\s*$a\s*\]/$b/g;
    return $str if $noSub; 
    return ReplaceAlias($str, $b);
    
} 

sub MakeType {
    my %cmds = %{$_[0]};
    my $alias = $_[1];
    my $dmenuParams = $_[2]; 
    my %newtype = (apps => {}, default => $alias);

    $newtype{apps} = \%cmds;

    foreach my $c (keys %{$newtype{apps}}) {
	my $command = $newtype{apps}{$c};
	if (defined reftype $command) {
	    my @t = keys %{$command}; 
	    $newtype{apps}->{$c} = BuildCacheHelper($command, \@t, $dmenuParams);
	    
	} else {
	    $command = Trim($command); 
	    if ($command =~ /(\$\[ [^\]]+ \])/x) {
		$command = ReplaceAliasWith($command, $1, $alias, 1) unless $1 =~ /args/;
		$newtype{apps}->{$c} = $command;
	    }
	}
        
    }

    return \%newtype; 
}


    
sub HandlePkill {
    my @ps = qx( ps -e ),
    my @processes = ();
    map { my @a = split ' ', $_ ; push @processes, $a[3] } @ps;
    my %p = ();
    map {
	my @z = split '/', $_;
	$p{$z[0]}++;
    } @processes;

    @processes = keys %p;

    $command->{apps}->{pkill} = {};
    $command->{pkill}->{apps} = {};
    
    map {
	$command->{pkill}->{apps}->{$_} = "pkill $_";
    } @processes;

    Executor($command->{pkill});
}

sub Handlei3Colors {
    my $location = $mainconfig->{config}->{"i3-colors"};
    my @themes = qx( $location --show ),
    $command->{apps}{"i3-colors"} = {}; 
    $command->{apps}{"i3-colors"}{"apps"} = {}; 
    foreach my $theme (@themes) {
	my ($idx, $theme) = split " ", $theme;
	$command->{apps}{"i3-colors"}{"apps"}{$theme} = sprintf "%s --theme %s", "$location", $idx; 
    }
    Executor($command->{apps}{"i3-colors"}); 
}

sub ShowDrawers {
    my @allcats = keys %{$command->{apps}};
    my $i3config = $mainconfig->{config}->{"i3config"}; 
    my $prog = ""; 
    my $str = "";
    my $len = 0;
    my $dmenuParams = GetDmenuParameters();
    
    map { ++$len if $_ =~ /[[:alnum:]]/ } @allcats;
    $prog = ShowCategories(\@allcats, $dmenuParams);


    if ($prog eq "i3-colors") {
	Handlei3Colors(); 
    } elsif ($prog eq "pkill")  { 
	HandlePkill(); 
    } else {
	my $isWeb = $prog eq "Websites" ? 1 : 0; 
	Executor($command->{apps}{$prog}, $dmenuParams, $isWeb); 
    }
}

sub Normal {
    my $dmenuParams = GetDmenuParameters();
    qx/dmenu_run $dmenuParams/;
    exit;
}

sub AppendCommand {
    my ($category, $alias) = @_; 
	      
    if ($alias =~ /::/) {
	unless ($command->{$category}) {
	    $command->{$category} = {}; 
	    $command->{$category}->{'apps'} = {}; 
	}
        
	if ($alias =~ /,/) {
	    my @aliases = split /\s*,\s*/, $alias;
	    map {
		my ($a, $c) = split /\s*::\s*/, $_;
		($a, $c) = (Trim($a), Trim($c));
		$command->{$category}->{apps}->{$a} = $c;
	    } @aliases;

	} elsif ($alias ne "") {
	    $category = Trim($category);
	    my ($a, $c) = split /\s*::\s*/, $alias;
	    $command->{$category}->{apps}->{$a} = $c;
	}
    } elsif ($alias ne "" and $alias !~ /::/) {
	die "Invalid format provided for -m INPUT.\n";
    }
    WriteConfig();
}

sub BuildCache {
    my ($hashref, $keys, $dmenu) = @_;

    return $hashref if scalar @$keys == 0;

    foreach my $k (@$keys) {
	if (defined reftype $hashref->{apps}{$k}) {
	    my @t = keys %{$hashref->{apps}{$k}{apps}}; 
	    $hashref->{apps}{$k} = BuildCache($hashref->{apps}{$k}, \@t, $dmenu); 
	}
    }

    if (defined $hashref->{types}) {
	$hashref = BuildCacheHelper($hashref, $keys, $dmenu); 
    }

    return $hashref; 
}


sub BuildCacheHelper {
    my $hashref = $_[0];
    my $keys = $_[1];
    my $dmenuParams = defined $_[2] ? $_[2] : GetDmenuParameters();
    
    return $hashref if scalar @$keys == 0;

    my $currentKey = $keys->[0];

    if ($hashref->{types}) {
	my $parent = clone $hashref->{apps};
	$hashref->{apps} = {};

	my %types = %{$hashref->{types}}; 
	my @allTypes = keys %types; 
	my @allTypesAliases = @types{@allTypes}; 
        
	my $alias = $allTypesAliases[0];
	my $newAlias = MakeType($parent, $alias, $dmenuParams);
	delete $hashref->{types}; 
	$hashref->{apps}->{$allTypes[0]} = $newAlias;
        
	for (my $i=1; $i<scalar @allTypes; $i++) {
	    my $oldalias = $allTypesAliases[0]; 
	    my $newalias = $allTypesAliases[$i];
	    my $thisAlias = clone $newAlias;
	    $hashref->{apps}->{$allTypes[$i]} = $thisAlias;
	}
    }

    if (defined reftype $hashref->{apps}->{$currentKey}) {
	my @kls = keys %{$hashref->{apps}->{$currentKey}->{apps}}; 
	return BuildCacheHelper($hashref->{apps}->{$currentKey}, \@kls, $dmenuParams); 
    }
    
    my @rest = @{$keys}[(1..scalar(@$keys)-1)];
    return BuildCacheHelper($hashref, \@rest, $dmenuParams); 

}


# No need to send the prog. Just send the hashref;

sub Executor {
    my %hashref = %{$_[0]};
    my $dmenuParams = defined $_[1] ? $_[1] : GetDmenuParameters();
    my $isWebsite = $_[2]; 
    my $default = $hashref{default} ? $hashref{default} : "";

    %hashref = %{$hashref{apps}}; 
    my @keys = keys %hashref;
    @keys = SortCategories(\@keys);
    
    my $prog = ShowCategories(\@keys, $dmenuParams);

    my $ref = ""; 
    if (defined reftype $hashref{$prog}) {
	Executor($hashref{$prog}, $dmenuParams, $isWebsite); 
    } else {
	if ($prog =~ /\w/) {
	    if (defined $hashref{$prog}) {
		$ref = $hashref{$prog};
	    } elsif ($default) {
		my $defaultAliasExpanded = $config->{aliases}->{GetAliasName($default)};

		if ($isWebsite) {
		    $ref = "$default https://www.duckduckgo.com/?q=" . uri_encode($prog); 		    
		} elsif ($defaultAliasExpanded =~ /(\$\[\s*args\s*\])/) {
		    $ref = $defaultAliasExpanded =~ s/\$\[\s*args\s*\]/$prog/r; 
		} else {
		    $ref = "$default $prog"
		}
	    } else {
		return; 
	    }
	} else {
	    return; 
	}
	
	$ref = ReplaceAllAliases($ref);
	print $ref, "\n";
	qx($ref); 
    }
}
    
    
sub dd { print Dumper $_[0] } 

=FileManager
- can only be used with rofi

features: 
- bookmarks section
- use batch opening files can be done. typing 'mark' will the user into the 'mark' menu which will contain the same filelist. Use the -mesg feature of rofi to indicate the mark status and additionally, the pwd. 
- if default: is present, directly exec the link else use another menu. 
- use everything in the group: to populate the individual: 
- for cp, mv, similar use the -mseg feature to traverse among the directories. display a new filelist for each traversal. 
- user can type: goto [DIRECTORY] to jump to that directory
- user can type: use @a:[appstring] @e:[ext] to open menus which contain only THOSE files which have the extension .[ext]
- user can set options using 'set [option] [on|off]'. Some options: [hidden, follow_symlinks]
=cut

