#!/usr/bin/python3  

import argparse as argp
import re, sys, os

# params are parsed into strings
def find_theme_by_regex(regex:str, themes:list) -> str:
    for i in themes:
        if re.search(regex, i):
            return i
    return False

def find_theme_by_regex_interactive(themes:list) -> str:
    def _print_themes() -> None:
        for idx,i in enumerate(themes):
            print(f'{idx}> {i.split("/")[-1]}')

    def _trim(s) -> str:
        return re.sub('^\s*|\s*$', '', s)

    while True:
        _print_themes()
        inp = input('% ')
        inp = _trim(inp)
        if inp == 'help':
            print('Input the index of the required theme or a regex or substring.')

        if n := re.search('^\d+$', inp):
            n = int(n.group(0))
            if n > len(themes) or n < 0:
                print(f'Invalid INDEX provided: {n}')
            return themes[n]
        elif w := re.search('\w', inp):
            if re.search('quit|exit', inp):
                sys.exit(1)
            if w := find_theme_by_regex(inp, themes):
                return w

def get_themes(loc:str) -> list:
    loc = re.sub("/$", "", loc)
    if not os.path.exists(loc):
        print('No themes have been made yet. Make some new themes first.')
        sys.exit(1)
    themes = os.listdir(loc)
    if not len(themes) > 0:
        return False
    themes = [f"{loc}/{i}" for i in themes]
    return themes

def load_theme(loc:str) -> str:
    with open(loc) as FH:
        return FH.read()

def save_theme(theme_str:str, theme_name:str, themes_dir:str) -> None:
    if not os.path.exists(themes_dir):
        os.mkdir(themes_dir)

    with open(f'{themes_dir}/{theme_name}.theme', 'w') as FH:
        FH.write(theme_str)

def get_current_theme_name(loc:str) -> None:
    if dat := get_current(loc):
        print(dat['name'])

def load_theme_and_apply(save_loc:str, loc:str):
    d = parse(load_theme(loc))
    apply(d, save_loc)
    print(f'{d["name"]} successfuly applied')

def parse(s) -> dict:
    d = None
    if  d := re.findall('(\w+)\s*=\s*"([^"]+)"', s):
        return dict(d)
    elif d := re.findall('(\w+)\s*"([^"]+)"', s):
        return dict(d)
    else:
        return None

def get_current(loc:str) -> dict:
    with open(loc) as FH:
        dat = FH.read()
        dat = parse(dat)
        if not dat:
            return False
        return dat

def hash_to_theme_str(dat:dict) -> str:
    s = ""
    for k,v in dat.items():
        s = f'{k} "{v}"\n{s}'
    return s

def apply(dat:dict, loc:str):
    with open(loc, 'w') as FH:
        FH.write(hash_to_theme_str(dat))
        return True
    return False

def translate(args_obj, loc, d={}) -> dict:
    other = {}

    tr = {
        "bgn" : "bg_normal",
        "bgf" : 'bg_focus',
        "bgu" : 'bg_urgent',
        "bgm" : 'bg_minimize',

        "fgn" : "fg_normal",
        "fgf" : 'fg_focus',
        "fgu" : 'fg_urgent',
        "fgm" : 'fg_minimize',

        "g"   : "gap",
        "bw"  : "border_width",
        "bn"  : "border_normal",
        "bf"  : "border_focus",
        "bm"  : "border_marked",

        "f"   : "font",
        "name": "name",
    }

    for i in tr.keys():
        try:
            if attr := getattr(args_obj, i):
                translated_key = tr[i]
                attr = re.sub('"', '', attr)
                if re.match('^#', attr):
                    e = False
                    if not re.match('^#[0-9a-fA-F]+$', attr):
                        print(f'Not a hex: {attr} (param: {i})')
                        e = True
                    if e == True:
                        sys.exit(1)
                    else:
                        d[translated_key] = attr
                else:
                    d[translated_key] = attr
        except AttributeError:
            pass

    try:
        print(args_obj)
        if attr := getattr(args_obj, "other"):
            if other := parse(attr):
                other = other
    except AttributeError:
        other = None

    if len(d) > 0:
        current_config = None
        if current_config := get_current(loc):
            current_config.update(d)
            d = current_config
        if other:
            d.update(other)
        return d

    return None

p = argp.ArgumentParser("Apply a theme to awesome wm")
aa = p.add_argument

aa("--bgn", metavar='STR', type=str, default=None, help="Normal background color",)
aa("--bgf", metavar='STR', type=str, default=None, help="Focused background color",)
aa("--bgu", metavar='STR', type=str, default=None, help="Urgent background color",)
aa("--bgm", metavar='STR', type=str, default=None, help="Minimized background color",)

aa("--fgn", metavar='STR', type=str, default=None, help="Normal foreground color",)
aa("--fgf", metavar='STR', type=str, default=None, help="Focused foreground color",)
aa("--fgu", metavar='STR', type=str, default=None, help="Urgent foreground color",)
aa("--fgm", metavar='STR', type=str, default=None, help="Minimized foreground color",)

aa("--g", metavar='STR', type=str, default=None, help="Gaps between windows",)
aa("--bw", metavar='STR', type=str, default=None, help="Border width",)
aa("--bn", metavar='STR', type=str, default=None, help="Normal border color",)
aa("--bf", metavar='STR', type=str, default=None, help="Focused border color",)
aa("--bm", metavar='STR', type=str, default=None, help="Marked border color",)

aa("--name", metavar='STR', type=str, default=None, help="Name of the current theme")
aa("--loc", metavar='STR', type=str, default=os.environ['HOME'] + '/.config/awesome/current_theme.list', help='Default location of user defined theme ($HOME/.config/awesome/current_theme.list)')

aa('--theme', metavar='STR', type=str, help="Use regex to apply the desired theme")
aa('--theme-menu',  action='store_true', help="Interactive menu to choose a theme")
aa('--themes-dir', metavar='STR', type=str, default=os.environ['HOME'] + '/.config/awesome/awesome_themes', help='Look in THIS directory. Default location is ($HOME/.config/awesome/themes)')

aa('--other', metavar='STR', type=str, help='Pass other args in the form k=v::k1=v1::k2=v2...')

args = p.parse_args()

if args.theme or args.theme_menu:
    themes = get_themes(args.themes_dir)
    if not themes:
        print('You need to make some themes first.')
        sys.exit(1)

    current = ""
    if args.theme_menu:
        current = find_theme_by_regex_interactive(themes)
    else:
        current = find_theme_by_regex(args.theme, themes)
        if not current:
            print('Regex did not match anything.')
            sys.exit(1)
    load_theme_and_apply(args.loc, current)
    sys.exit(0)

if translated := translate(args, args.loc):
    if apply(translated, args.loc):
        print(f'{args.name} successfuly applied.')
        save_theme(hash_to_theme_str(translated), args.name, args.themes_dir)
