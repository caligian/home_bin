#!/usr/bin/python3

import json, time, pytz, os, re
from datetime import datetime
from argparse import ArgumentParser


class Bookmark:
    def __init__(self):
        self.bookmarks_file = os.path.join(os.getenv("HOME"), ".bookmarks.json")
        self.bookmarks = {}
        self.exists = os.path.isfile(self.bookmarks_file)
        self.load()
        self.clean()

    def clean(self):
        results = {}

        for path, props in self.bookmarks.items():
            if not os.path.exists(path):
                continue

            results[path] = props
            current = results[path]

            if props.get('context'):
                context = {}

                for linenum, line in props['context'].items():
                    saved = self.get_line_from_file(path, linenum)

                    if saved == line:
                        context[linenum] = saved

                current["context"] = context

        self.bookmarks = results

    @staticmethod
    def get_line_from_file(path: str, linenum: int) -> dict:
        if not os.path.isfile(path):
            raise ValueError(f"expected file, got {path}")
                                                                         
        if type(linenum) != int:
            linenum = int(linenum)
                                                                         
        with open(path) as fh:
            lines = fh.readlines()
            linenum = linenum - 1
                                                                         
            if len(lines) < linenum or linenum < 0:
                raise ValueError(f"invalid line ({linenum}) for {path}")
            else:
                return lines[linenum]

    def get_line(self, 
                 path: str, 
                 line: list[int] | int, 
                 dest: dict) -> dict | ValueError:

        def to_list(x):
            if type(x) != list:
                return [x]
            else:
                return x

        for x in to_list(line):
            dest[x] = self.get_line_from_file(path, x)

        return dest


    def save(self) -> bool:
        with open(self.bookmarks_file, "w") as fh:
            json.dump(self.bookmarks, fh)
            return True

    def load(self) -> dict | None:
        if not self.exists:
            raise ValueError(
                f"{self.bookmarks_file} does not exist. please add some bookmarks first"
            )

        with open(self.bookmarks_file) as fh:
            self.bookmarks = json.load(fh)
            return self.bookmarks

    def json(self):
        if not self.bookmarks:
            return

        print(json.dumps(self.bookmarks))

    def add(self, file_path, line=None, desc="") -> dict | ValueError:
        if file_path[-1] == "/":
            file_path = file_path[:-1]

        if re.match(r'^~', file_path):
            file_path = file_path.replace('~', os.getenv('HOME'))

        isfile = os.path.isfile(file_path)
        isdir = os.path.isdir(file_path)

        if not isfile and not isdir:
            raise ValueError(f"{file_path} is neither a file nor a directory")

        file_path = os.path.abspath(file_path)
        obj: dict = self.bookmarks.get(file_path, {})
        context: dict = obj.get('context', {})

        if line:
            obj.update({
                "file": isfile,
                "dir": isdir,
                "context": context,
                "desc": desc,
                "path": file_path,
                "creation_time": time.time(),
            })
        else:
            obj.update({
                "file": isfile,
                "dir": isdir,
                "desc": desc,
                "path": file_path,
                "creation_time": time.time(),
            })

        self.bookmarks[file_path] = obj
        self.save()

        return self.bookmarks[file_path]

    def delete(self, file_path) -> dict:
        file_path = file_path.replace("~", os.getenv("HOME"))

        if self.bookmarks.get(file_path):
            self.bookmarks.pop(file_path)

        self.save()
        return self.bookmarks

    def print(self):
        if not self.bookmarks:
            return

        for path, props in self.bookmarks.items():
            if props["file"]:
                print(f"path: {props['path']}")
            else:
                print(f"path: {props['path']}/")

            creation_time = props["creation_time"]

            creation_time = datetime.fromtimestamp(
                time.time(), tz=pytz.timezone("Asia/Kolkata")
            ).strftime("%d/%m/%Y at %H:%M:%S")

            print(f"creation time: {creation_time}")

            if desc := props.get('desc'):
                print(f"description: {desc}")

            if props.get("context"):
                print(f'context:')
                for linenum, line in props['context'].items(): 
                    line = line.rstrip()
                    print(f"  {str(linenum).rjust(3)}: {line}")

            print()

    @staticmethod
    def main():
        parser = ArgumentParser(description="Simple bookmarks manager")
        add = parser.add_argument

        add("-i", "--path", default=None)
        add("-l", "--line", default=None, type=int, help="use linenum as context")
        add("-d", "--desc", default="", help="bookmark description")
        add("-x", "--delete", default=None, help="remove path from bookmarks")
        add(
            "-o",
            "--json",
            default=False,
            action="store_true",
            help="print bookmarks as json",
        )
        add(
            "-p",
            "--print",
            default=False,
            action="store_true",
            help="pretty print bookmarks",
        )

        args = parser.parse_args()
        fname = args.path
        self = Bookmark()

        if args.print or args.json:
            if args.print:
                self.print()
            else:
                self.json()
        else:
            if not fname:
                raise ValueError(f"path missing")

            if args.delete:
                self.delete(fname)
            else:
                self.add(fname, **{"line": args.line, "desc": args.desc})


Bookmark.main()
