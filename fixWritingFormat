#!/usr/bin/perl 

# Does the following : 
# 1. [space]{2,}		 -> [space]
# 2. [space].[space]		 -> .[space] 
# 3. [space],[space]		 -> ,[space]
# 4. ^[a-z]			 -> ^[A-Z]
# 5. .[a-z]			 -> .[A-Z]
# 6. [space]?i[space]		 -> [space]?I[space]
# 7. "[a-z]		         -> "\U[a-z]
# 8. [a-z]\"			 -> [a-z].\"
# 9. " [!?.]			 -> "
# 10. Expand names of days, months and capitalize them
# 11. \d[space]+(thl|rd|st)	 -> \d(th|rd|st)
# 12. \w[.,]\w			 -> \w[.,] \w
# 13. ['"]\w                     -> ["'][space]\w
# Caveats
# * Do not use abbreviations of the old style, ie, containing periods. for eg. M.S.S

package FixWritingFormat;

use autodie;
use strict;
use warnings;
use Getopt::Std; 


our $TRUE = 1;
our $FALSE = 0;

our %options = ("abbrevFile"      => "",
		"outFile"	  => "",
		"inFile"	  => "",
		"properNounsFile" => "");


our %optionFlags   = ("stdin"	         => $TRUE,
		      "stdout"		 => $TRUE,
		      "useDays"		 => $FALSE,
		      "useMonths"	 => $FALSE);


our %abbrevs	 = ("abbrevs"		 => {}, # your custom abbrevs
		    "days"		 => {'mon' => 'Monday', 'tues' => 'Tuesday', 'wed' => 'Wednesday', 'thurs' => 'Thursday' , 'fri' => 'Friday', 'sat' => 'Saturday', 'sun' => 'Sunday'},
		    "months"		 => {'jan' => "January", 'feb' => "February", 'mar' => "March", 'apr' => "April", 'may' => "May", 'june' => 'June', 'july' => 'July', 'aug' => 'August', 'sept' => 'September', 'oct' => "October", 'nov' => 'November', 'dec' => 'December'}, 
		    "properNouns"	 => []);


sub GetAbbrevsFromFile {
    my $c = 0;
    if ($options{"abbrevFile"} ne "") {
	open my $FH, "<", $options{"abbrevFile"};
	
	# abbrev = abbrev expansion
	while (my $line = <$FH>) {
	    chomp $line; 
	    if ($line =~ /(\w+)\s*=\s*([\w\s]+)/) {
		++$c;
		$abbrevs{"abbrevs"}->{$1} = $2;
	    }
	    elsif ($line =~ /(?!\w)/) {
		next;
	    }
	    else {
		die "$.: Wrong specification of abbreviation and its expanded value [$line].\n";
	    }
	} close $FH;  die "No valid abbreviaton and abbreviation found in $options{'abbrevFile'}\n" if $c == 0;
    } 
    
    if ($optionFlags{"useDays"} == $TRUE) {
	foreach my $day (keys %{$abbrevs{"days"}}) {
	    $abbrevs{"abbrevs"}->{$day} = $abbrevs{"days"}->{$day};
	}
    }
    
    if ($optionFlags{"useMonths"} == $TRUE) {
	foreach my $month (keys %{$abbrevs{"months"}}) {
	    $abbrevs{"abbrevs"}->{$month} = $abbrevs{"months"}->{$month};
	}
    }
    
    if ($options{"properNounsFile"} ne "") {
	open my $FH, "<", $options{"properNounsFile"};

	# proper noun on every single line. Note that every instance of these/this word (on each line) found will be replaced with a capitalized version of itself.
	$c = 0;
	while (my $line = <$FH>) {
	    chomp $line; 
	    if ($line =~ /^\s*(\w.+)/) {
		++$c;
		my $match = $1 =~ s/\s+$//r;
		$match =~ s/\s{2,}/ /g;
		if ($match =~ /(?<=\w)(?:\s)(?=\w)/) {
		    my @words = split " ", $match;
		    $match = join(" ", map { ucfirst $_ } @words);
		} else {
		    $match = ucfirst $match;
		}
		$abbrevs{"abbrevs"}->{lc $match} =  $match;
	    }
	} close $FH; die "No proper nouns were found in $options{'properNounsFile'}\n" if $c == 0;
    }
}
	


sub SubAbbrevs {
    my $line = $_[0]; # should be a reference
    my %a = %{$abbrevs{"abbrevs"}};
    foreach my $replacement (keys %a) {
	my $replaceWith = $a{$replacement};
	$$line =~ s/(?<=\b)$replacement/$replaceWith/g;
    }
}


sub New {
    my $class = shift;

    my $exit = $FALSE;

    if ($optionFlags{"stdin"} != $TRUE) {
	die "$options{'abbrevFile'} path is invalid \n" if $options{'abbrevFile'} ne "" and ! -f $options{'abbrevFile'};
	die "$options{'properNounsFile'} path is invalid\n" if $options{'properNounsFile'} ne "" and ! -f $options{'properNounsFile'};
	die "$options{'inFile'} path is invalid\n" if $options{'inFile'} ne "" and ! -f $options{'inFile'};
	die "$options{'outFile'} path is invalid\n" if $options{'outFile'} ne "" and ! -f $options{'outFile'};    
    }

    
    if ($optionFlags{"useDays"}        == $TRUE or
	$options{"abbrevFile"}         ne ""    or
	$options{"properNounsFile"}    ne ""    or
	$optionFlags{"useMonths"}      == $TRUE) {
	GetAbbrevsFromFile();
    }
    

    my $self = {"options" => \%options, "optionFlags" => \%optionFlags, "abbrevs" => \%abbrevs};
    
    bless $self, $class;
    return $self;

}

sub FixFormat {
    my $line = shift;
    no warnings 'uninitialized'; 
    $$line =~ s/’/'/g;
    $$line =~ s/“/"/g;
    $$line =~ s|(?<=")\s*([[:alpha:]])([^"]+[a-z])\s*(?=")|\U$1\E$2.|g || $line =~ s|(?<=")\s*([[:alpha:]])([^"]+[a-z][.,?!])\s*(?=")|\U$1\E$2|g;
    $$line =~ s/(?<=")([a-z])([^"]+)/\U$1\E$2/g;
    $$line =~ s/(?<=\S)(?:")([^"]+)(?=")/ "$1/g;
    $$line =~ s|(?<=')\s*([^']+[^\s'])\s*'|$1'|g;
    $$line =~ s/^\s*([a-z])/\U$1/g;
    $$line =~ s/\s{2,}/ /g;
    $$line =~ s/(?<=[A-Za-z])\s*([.,])\s*/$1/g;
    $$line =~ s/(?<=,)(?=[^,\s])/ /g;
    $$line =~ s/(?<=[.!?])\s*(\w)/ \U$1/g;
    $$line =~ s/(?<=\d)\s*(?=st|rd|th)(?=[\s.!,?])//g;
    $$line =~ s/(?<=\b)i(?=\b)/I/g;
    $$line =~ s/(?<=\b)[dm](r|s)(?=\.)/M$1/g;
    $$line =~ s/(?<=\w)\s*(?<!\.)\s*$/./g;
}

    
sub SubstitutionLoop {
    my $self = shift;
    my $stdout = $self->{"optionFlags"}->{"stdout"};
    my $outFile = $self->{"options"}->{"outFile"}; 
    my $save = "";
    my $FH;

    if ($self->{"optionFlags"}->{"stdin"} == $TRUE) {
	my $c = 0;
	while (my $line = <STDIN>) {
	    ++$c; 
	    SubAbbrevs(\$line);
	    FixFormat(\$line);
	    if ($stdout == $FALSE) {
		$save .= $line . "\n";
	    } else {
		print $line, "\n";
	    }
	} die "No input?\n" if $c == 0; 
    }
    
    elsif ($self->{"optionFlags"}->{"stdin"} == $FALSE) {
	open my $FH, "<", $options{"inFile"};
	my $c = 0;
	while (my $line = <$FH>) {
	    ++$c; 
	    SubAbbrevs(\$line);
	    FixFormat(\$line);
	    if ($stdout == $FALSE) {
		$save .= $line . "\n";
	    } else {
		print $line, "\n";
	    }
	} close $FH;  die "Is this a blank file?\n" if $c == 0;
    }

    if ($stdout == $FALSE) {
	open my $OUT, ">", $outFile;
	print $OUT "$save\n" ;
	close $OUT; 
    }
}


my $help ="Fix your writing format and other stuff.
[FLAGS]
-h : Show help
-n : Use stdin for input
-s : Use stdout for output
-d : Expand the names of days
-m : Expand the names of months 

[PARAMETRIC]
-i : Input file
-o : Output file
-a : File containing the abbreviations and their expansion in the form 'ABBREV = EXPANSION'
-p : File containing the proper nouns which are to be capitalized

";

our $opt_h = $FALSE; 		        # help        (FLAG)
our $opt_i = "";			# input file  
our $opt_a = "";			# abbrev file
our $opt_d = $FALSE;			# use dates   (FLAG)
our $opt_m = $FALSE;			# use months  (FLAG)
our $opt_n = $FALSE; 		        # use stdin   (FLAG)
our $opt_p = "";
our $opt_o = ""; 

getopts("hdmnp:i:o:a:");

print($help, "\n"), exit if $opt_h;

$optionFlags{'stdout'}		 = $opt_o ne "" ? $FALSE : $TRUE;
$optionFlags{"stdin"}		 = $opt_n;
$optionFlags{"useDays"}		 = $opt_d;
$optionFlags{"useMonths"}	 = $opt_m;

$options{"abbrevFile"}		 = $opt_a;
$options{"inFile"}		 = $opt_i;
$options{"outFile"}		 = $opt_o;
$options{"properNounsFile"}	 = $opt_p;

my $fixWritingFormat = FixWritingFormat->New();
$fixWritingFormat->GetAbbrevsFromFile(); 
$fixWritingFormat->SubstitutionLoop();

hello world. wow what a motherfucker. -n
hello world. wow what a motherfucker. -n -o hello
